# MVI DSL
- [Начало работы](#начало-работы)
- [Добавление трансформаций](#добавление-трансформаций)
- [Фильтрация по классу](#фильтрация-по-классу)
- [Типы трансформаций](#типы-трансформаций)

## Начало работы
Для того, чтобы начать работать с DSL, необходимо унаследовать Middleware, использующийся в проекте, от [DslFlowMiddleware][DslFlowMiddleware], и переопределить метод `transform(eventStream)` следующим образом:
```kotlin
    override fun transform(eventStream: Flow<SimpleEvent>): Flow<SimpleEvent> {
        return eventStream.transformations {
            // Здесь будут перечислены возможные трансформации
        }
    }
```

## Добавление трансформаций
Для того, чтобы добавить эти трансформации, нужно вызвать либо метод `addAll(vararg transformations: Flow<E>)`, либо унарный плюс: `+Flow<T>` для добавления по очереди.

## Фильтрация по классу
Трансформации можно применять только к событиям определенных классов со следующим синтаксисом:
`<Класс события> <тип трансформации> <трансформация>`
Например, с помощью записи ниже, мы обновляем данные, как только получаем событие Reload:
`Reload::class eventMapTo { loadData() }`

## Типы трансформаций
1. **mapTo** - трансформация события в событие. Используется, когда например событие клика по кнопке нужно трансформировать в событие открытие диалога.
```kotlin
    ButtonClicked::class mapTo { OpenSelectPhotoDialog() } 
```
1. **eventMapTo** - трансформация события в поток событий. Полезно, например когда клик кнопки трансформируется в поток событий начала запроса к серверу, а когда ответ получен - в еще одно событие ошибки или успеха запроса. То есть получаем событие, а возвращаем поток событий.
```kotlin
    ReloadBtnClicked::class eventMapTo { 
        interactor.loadData()
            .asRequest(LoadDataEvent())
    }
```
1. **streamMapTo** - трансформация потока событий в другой поток событий. Эта трансформация полезна, когда трансормации eventMapTo уже недостаточно и требуется модицицировать флоу событий используя операторы реактивных цепочек. Наприер filter, debounce, distinctUntilChanged и тд.
```kotlin
    TextChanged::class streamMapTo { textChangedFlow -> 
        textChangedFlow
            .map { it.text } 
            .filter { it.isNotEmpty() }
            .debounce(300L, TimeUnit.MILLISECONDS)
            .distinctUntilChanged()
            .map { TextChangedDebounced(it) } 
    }
```
1. **react** - когда нужно как-то отреагировать на событие, но не возвращать при этом никакого события в хаб. Например вызывать метод аналитики. То есть обратиться к чему-то, что при этом не потребует дальнейших обновлений состояния или трансформаций в другие события.
```kotlin
    ButtonClicked::class reactTo { event -> 
        analyticsService.sendEvent(TEXT_CHANGED, event.text) 
    } 
```
1. **decompose** *(не поддерживается в текущей версии)* - эта трансформация используется для обработки событий в другом Middleware. Например, на последних проектах в отдельный Middleware была вынесена логика обработки команд навигации, и на всех экранах, где требовалось совершать какие-то переходы в middleware, события навигации передавались для обработки в отдельный NavigationMiddleware.  